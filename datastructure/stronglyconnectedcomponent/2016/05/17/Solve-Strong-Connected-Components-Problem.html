<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Your awesome title</title><!-- Bootstrap --><!-- Latest compiled and minified CSS --><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous"><!-- Optional theme --><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap-theme.min.css" integrity="sha384-fLW2N01lMqjakBkx3l/M9EahuwpSfeNvV63J5ezn3uZzapT0u7EYsXMjQV+0En5r" crossorigin="anonymous"><!-- Latest compiled and minified JavaScript --><script src="//cdn.bootcss.com/jquery/2.2.1/jquery.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script><!-- Local Css --><link href="/blog/css/main.css" rel="stylesheet"><link href="/blog/css/monokai.css" rel="stylesheet"><!-- MathJax --><script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script><!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries --><!--[if lt IE 9]>
    <script src="http://cdn.staticfile.org/html5shiv/3.7.2/html5shiv.min.js"></script>
    <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
    <![endif]--></head><body><nav class="navbar navbar-default" role="navigation"><div class="container"><div class="navbar-header"><button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1"><span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span></button> <a class="navbar-brand" href="/blog/">Your awesome title</a></div><div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1"><ul class="nav navbar-nav navbar-right"><li><a href="/blog/">Home</a></li><li><a href="/blog/about/">About</a></li></ul></div></div></nav><div class="content"><div class="container"><div class="row"><div class="main col-lg-8 col-md-8 col-sm-12 col-xs-12"><article class="post"><!-- Header --><header class="post-header"><h1 class="post-title"><a href="/blog/datastructure/stronglyconnectedcomponent/2016/05/17/Solve-Strong-Connected-Components-Problem.html">求解强连通分量</a></h1><p class="post-meta">May 17, 2016 <a href="/blog/category/datastructure/" title="数据结构">数据结构</a>, <a href="/blog/category/stronglyconnectedcomponent/" title="强连通分量">强连通分量</a></p></header><!-- Content --><div class="post-content"><h4 id="section">强连通分量</h4><p>无向图的强连通分量相当的容易得到：图中不相连的部分自然构成了图的强连通分量（<em>Figure 1</em>）。如我们所见，深度优先搜索可以有效的解决这个问题：每次重新开始算法就是一个新的连通分量。 <img src="/blog/images/1463401383607.png" alt="Figure 1. An undirected graph | center | 300x0"></p><p>有向图的强连通分量更加微妙。在有向图<script type="math/tex">G=(V, E)</script>中两个节点u和v，如果存在从u到v的路径并且存在从v到u的路径，则称uv是连通的。在<em>Figure 2</em>中有四个强连通分量。</p><p><img src="/blog/images/1463402768199.png" alt="Figure 2. A directed graph and its strongly connected components"></p><p>如果我们把每个强连通分量缩成一个单点，并且如果两个分量中的节点间存在边，则按该边的方向连接两个点，如此便构成了一个新的有向无环图（<strong>DAG</strong>）（<em>Figure 2</em>）。原因很简单：一个环包含多个强连通分量必然会将他们合并成一个。我们可以这么说：<strong><code class="highlighter-rouge">每个有向图是它的强连通分量的有向无环图</code></strong></p><p>这一重要的结论允许我们可以分两层来求解有向图的强连通分量问题：</p><ul><li>首先我们有个<strong>DAG</strong>——一个比较简单的结构。我们知道一个<strong>DAG</strong>至少有一个源点（入度为0的点）并且至少有个终点（出度为0的点），而且可以拓扑排序。</li><li>紧接着我们可以把<strong>DAG</strong>中的节点展开来干我们想干的事，每个展开节点都是一个强连通图。</li></ul><p>如上的分解使得我们可以通过深搜（深度优先搜索）在线性时间内解决问题。讲算法之前我们先看一些结论：</p><blockquote><p><strong>Property 1</strong> 如果一个图的深搜开始于节点u，那么它将会遍历所有从u可达的点之后停止。因此，如果深搜开始于终点强连通分量中的一个节点（终点强连通分量即该强连通分量中没有边指向<em>DAG</em>中其他强连通分量），那么恰好它遍历完该强连通分量中的所有节点后就停止了。</p></blockquote><p>如图<em>Figure 2</em>，如果深搜开始于节点11（图中唯一的终点强连通分量的一个节点），那么在遍历11，12，10，9，7，8（正好是终点强连通分量的六个节点）后停止。<strong>Property 1</strong>给出找到第一个强连通分量的方法：从终点强连通分量中一个节点开始遍历，停止后输出所有遍历过的节点，即构成了一个强连通分量！</p><p>当然，这留给我们两个问题</p><ul><li>如何得到一个终点强连通分量中的节点</li><li>在输出第一个分量后如何继续输出第二，第三……</li></ul><p>我们先来解决第一个问题。没有简单的直接解决办法，但是有方法可以得到源点强连通分量中的一个节点。</p><blockquote><p><strong>Property 2</strong> 深搜中最晚结束的节点（这里的结束是指先遍历完其他可达的节点后才算起始节点的结束，类似树的后序遍历，根是最晚结束的）属于源点强连通分量。</p></blockquote><p><strong>Property 2</strong>源于一个更基本的事实：</p><blockquote><p><strong>Property 3</strong> <code class="highlighter-rouge">C</code> 和 <code class="highlighter-rouge">C'</code>是两个强连通分量并且存在一条由<code class="highlighter-rouge">C</code>中一个节点指向<code class="highlighter-rouge">C'</code>中一个节点的边，则深搜后<code class="highlighter-rouge">C</code>中这个先被访问的节点有比<code class="highlighter-rouge">C'</code>中任何一个节点都晚的结束时间。</p></blockquote><p><strong>Property 3</strong>的证明如下，存在有两种情况：<code class="highlighter-rouge">C</code>比<code class="highlighter-rouge">C'</code>先被访问，如此在深搜停止前已经访问完所有<code class="highlighter-rouge">C</code>和<code class="highlighter-rouge">C'</code>的所有节点，所以<code class="highlighter-rouge">C</code>起始访问节点具有最晚的结束时间。如果<code class="highlighter-rouge">C'</code>比<code class="highlighter-rouge">C</code>先访问，则在访问任何<code class="highlighter-rouge">C</code>的节点前深搜就停止了（<code class="highlighter-rouge">C</code>中的节点对于任何<code class="highlighter-rouge">C'</code>中节点不可达），所以结论仍然成了。</p><p>换种说法，<strong>Property 3</strong>可以如下描述：对图的强连通分量的拓扑排序既是将有向图的强连通分量按结束时间递减进行排序！这是广义的<strong>DAG</strong>拓扑排序算法。毕竟，<strong>DAG</strong>就是一个强连通分量为单个节点的有向图。</p><p><strong>Property 2</strong>提供了一种间接的方法解决第一个问题：考虑图<script type="math/tex">G = (V, E)</script>，图的反图就是图的所有边的方向反制，即<script type="math/tex">G^R = (V, E)^R</script>。<script type="math/tex">G^R</script>与原图有着相同的强连通分量。所以，我们对<script type="math/tex">G^R</script>进行深搜，最晚完成的节点就是图<script type="math/tex">G^R</script>源点强连通分量的一个节点——即原图<script type="math/tex">G</script>的终点强连通分量的节点。所以第一个问题解决了！</p><p>再来看第二个问题：在终点强连通分量输出后如何继续呢？解决方法<strong>Property 3</strong>已经说明：在我们输出第一个强连通分量后把它从图中删除，在<script type="math/tex">G^R</script>余下节点中深搜最晚完成的节点属于原图的余下部分终点强连通分量。因此，我们可以继续用<script type="math/tex">G^R</script>深搜信息来得到第二个强连通分量，直到结束。完整的算法如下：</p><p><em><code class="highlighter-rouge">Step 1</code></em> 在<script type="math/tex">G^R</script>上进行深搜。</p><p><em><code class="highlighter-rouge">Step 2</code></em>运用求解无向图强连通分量的算法，按<em>step 1</em>中得到的结束时间递减（由晚到早），处理原图的每个强连通分量。</p><hr><p>以上算法是<a href="https://zh.wikipedia.org/wiki/Kosaraju%E7%AE%97%E6%B3%95">Kosaraju算法</a>，wiki给出了<code class="highlighter-rouge">Java</code>的实现，下面是我在<a href="https://pta.patest.cn/pta/test/16/exam/3">PTA数据结构与算法</a>函数题第10题<a href="https://pta.patest.cn/pta/test/16/exam/3/question/705">Strongly Connected Components</a>的<code class="highlighter-rouge">C</code>实现</p><div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="cm">/*
typedef struct VNode *PtrToVNode;
struct VNode {
    Vertex Vert;
    PtrToVNode Next;
};
typedef struct GNode *Graph;
struct GNode {
    int NumOfVertices;
    int NumOfEdges;
    PtrToVNode *Array;
};
*/</span>

<span class="n">Graph</span> <span class="nf">ReverseGraph</span><span class="p">(</span><span class="n">Graph</span> <span class="n">G</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Graph</span> <span class="n">g</span> <span class="o">=</span> <span class="p">(</span><span class="n">Graph</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">GNode</span><span class="p">));</span>
    <span class="p">(</span><span class="o">*</span><span class="n">g</span><span class="p">).</span><span class="n">NumOfVertices</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">G</span><span class="p">).</span><span class="n">NumOfVertices</span><span class="p">;</span>
    <span class="p">(</span><span class="o">*</span><span class="n">g</span><span class="p">).</span><span class="n">NumOfEdges</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">G</span><span class="p">).</span><span class="n">NumOfEdges</span><span class="p">;</span>
    <span class="p">(</span><span class="o">*</span><span class="n">g</span><span class="p">).</span><span class="n">Array</span> <span class="o">=</span> <span class="p">(</span><span class="n">PtrToVNode</span> <span class="o">*</span><span class="p">)</span><span class="n">calloc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">PtrToVNode</span><span class="p">)</span> <span class="o">*</span> <span class="n">G</span><span class="o">-&gt;</span><span class="n">NumOfVertices</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">G</span><span class="o">-&gt;</span><span class="n">NumOfVertices</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">PtrToVNode</span> <span class="n">node</span> <span class="o">=</span> <span class="n">G</span><span class="o">-&gt;</span><span class="n">Array</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">ver</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Vert</span><span class="p">;</span>
            <span class="n">PtrToVNode</span> <span class="n">now</span> <span class="o">=</span> <span class="p">(</span><span class="n">PtrToVNode</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">VNode</span><span class="p">));</span>
            <span class="n">now</span><span class="o">-&gt;</span><span class="n">Vert</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
            <span class="n">now</span><span class="o">-&gt;</span><span class="n">Next</span> <span class="o">=</span> <span class="n">g</span><span class="o">-&gt;</span><span class="n">Array</span><span class="p">[</span><span class="n">ver</span><span class="p">];</span>
            <span class="n">g</span><span class="o">-&gt;</span><span class="n">Array</span><span class="p">[</span><span class="n">ver</span><span class="p">]</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>
            <span class="n">node</span><span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">g</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">stack</span><span class="p">[</span><span class="n">MaxVertices</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">visited</span><span class="p">[</span><span class="n">MaxVertices</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">k</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">DFS</span><span class="p">(</span><span class="n">Graph</span> <span class="n">G</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="kt">int</span> <span class="n">node</span><span class="p">)){</span>
    <span class="n">visited</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">PtrToVNode</span> <span class="n">vnode</span> <span class="o">=</span> <span class="n">G</span><span class="o">-&gt;</span><span class="n">Array</span><span class="p">[</span><span class="n">node</span><span class="p">];</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">vnode</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">vnode</span><span class="o">-&gt;</span><span class="n">Vert</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">DFS</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">vnode</span><span class="o">-&gt;</span><span class="n">Vert</span><span class="p">,</span> <span class="n">func</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">vnode</span> <span class="o">=</span> <span class="n">vnode</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">func</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">push</span><span class="p">(</span><span class="kt">int</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">stack</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">SCC</span><span class="p">(</span><span class="n">Graph</span> <span class="n">g</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">visit</span><span class="p">)(</span><span class="n">Vertex</span> <span class="n">V</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">visited</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">visited</span><span class="p">));</span>

    <span class="k">while</span><span class="p">(</span><span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">visited</span><span class="p">[</span><span class="n">stack</span><span class="p">[</span><span class="o">--</span><span class="n">k</span><span class="p">]])</span> <span class="p">{</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">DFS</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">stack</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">visit</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>



<span class="kt">void</span> <span class="n">StronglyConnectedComponents</span><span class="p">(</span> <span class="n">Graph</span> <span class="n">G</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">visit</span><span class="p">)(</span><span class="n">Vertex</span> <span class="n">V</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">visited</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">visited</span><span class="p">));</span>
    <span class="n">Graph</span> <span class="n">g</span> <span class="o">=</span> <span class="n">ReverseGraph</span><span class="p">(</span><span class="n">G</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">G</span><span class="o">-&gt;</span><span class="n">NumOfVertices</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">DFS</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">push</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">SCC</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">visit</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><hr><h4 id="section-1">参考：</h4><ol><li><a href="http://www.cs.berkeley.edu/~vazirani/s99cs170/notes/lec12.pdf">http://www.cs.berkeley.edu/~vazirani/s99cs170/notes/lec12.pdf</a></li><li><a href="http://blog.csdn.net/dm_vincent/article/details/8554244">dm_vincent的专栏</a></li></ol></div></article><nav><ul class="pager"><li class="previous"><a rel="prev" href="/blog/article/2016/04/20/I'm-Tired.html" title="I&#39;m Tired">&laquo; Previous</a></li></ul></nav></div><div class="sidebar col-lg-4 col-md-4 col-sm-12 col-xc-12"><!-- <aside class="about">
    <h3 class="aside-title">About</h3>
    <div class="aside-content">
        <p>
            Just one normal day to find some of it amazing.

        </p>
    </div>
</aside> --><aside class="category_list"><h3 class="aside-title">Categories</h3><div class="aside-content"><ul><li><a href="/blog/category/news/" title="News">News</a> (1)</li><li><a href="/blog/category/article/" title="article">article</a> (1)</li><li><a href="/blog/category/datastructure/" title="数据结构">数据结构</a> (1)</li><li><a href="/blog/category/stronglyconnectedcomponent/" title="强连通分量">强连通分量</a> (1)</li></ul></div></aside><aside class="subscribe"><h3 class="aside-title">Subscribe</h3><div class="aside-content"><p><a href="/blog/feed.xml">Subscribe Via RSS</a></p></div></aside></div></div></div></div><footer class="footer"><p><span class="footer-copyright">&copy; 2016 Your awesome title </span><span class="footer-gen">Gen By Jekyll 3.1.3</span></p></footer></body></html>